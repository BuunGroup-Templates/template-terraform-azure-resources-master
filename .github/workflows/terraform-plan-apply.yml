name: Terraform Plan and Apply

on:
  workflow_run:
    workflows: ["Generate Terraform Docs"]
    types:
      - completed
    branches:
      - main

  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (e.g., dev, staging, prod)'
        required: true
        default: 'dev'

      auto_apply:
        description: 'Automatically apply the plan after successful planning?'
        type: boolean
        default: false

      ref:
        description: 'Git ref (branch, tag, or SHA) to checkout'
        required: false
        default: 'main'

      runner_label:
        description: 'Runner label(s) to use (e.g., ubuntu-latest, self-hosted)'
        required: false
        type: string
        default: 'ubuntu-latest'

permissions:
  contents: read
  id-token: write
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  detect-topics:
    runs-on: ubuntu-latest
    outputs:
      is_master: ${{ steps.topics.outputs.is_master }}
    steps:
      - name: Get repository topics
        id: topics
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const topics = repo.topics || [];
            core.setOutput('is_master', topics.includes('template-master'));

  plan:
    name: Terraform Plan (${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'production' }})
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event.workflow_run.conclusion == 'success' && !contains(github.event.workflow_run.head_commit.message, '[skip ci]'))
    runs-on: ${{ github.event.inputs.runner_label || 'ubuntu-latest' }}
    environment: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.event.inputs.ref || github.ref }}

      - name: Determine Environment Name
        id: determine_env
        run: |
          ENV_NAME="${{ github.event.inputs.environment || 'production' }}"
          echo "Determined environment: $ENV_NAME"
          echo "environment_name=$ENV_NAME" >> $GITHUB_OUTPUT
          echo "secret_name=STATE_$(echo '$ENV_NAME' | tr '[:lower:]' '[:upper:]' | tr '-' '_')" >> $GITHUB_OUTPUT
        shell: bash

      - name: Check for Existing State Secret
        id: check_state_secret
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const secretName = '${{ steps.determine_env.outputs.secret_name }}';
            console.log(`Checking for secret: ${secretName}`);
            
            try {
              await github.rest.actions.getRepoSecret({
                owner: context.repo.owner,
                repo: context.repo.repo,
                secret_name: secretName
              });
              console.log(`Secret ${secretName} exists`);
              core.setOutput('exists', 'true');
            } catch (error) {
              if (error.status === 404) {
                console.log(`Secret ${secretName} does not exist`);
                core.setOutput('exists', 'false');
              } else {
                throw error;
              }
            }

      - name: Restore State File from Secret
        if: steps.check_state_secret.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const secretName = '${{ steps.determine_env.outputs.secret_name }}';
            
            console.log(`Restoring state from secret: ${secretName}`);
            
            // The secret value is available through the secrets context
            const encodedState = process.env[secretName];
            
            if (!encodedState) {
              throw new Error(`Secret ${secretName} is not available in environment`);
            }
            
            // The secret value is stored as base64, decode it
            const stateContent = Buffer.from(encodedState, 'base64').toString('utf8');
            
            // Write to terraform.tfstate
            fs.writeFileSync('terraform.tfstate', stateContent);
            console.log('State file restored successfully');
        env:
          ${{ steps.determine_env.outputs.secret_name }}: ${{ secrets[steps.determine_env.outputs.secret_name] }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: Terraform Init
        id: init
        working-directory: .
        continue-on-error: false
        run: terraform init -backend=false
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

      - name: Terraform Plan
        id: plan
        working-directory: .
        continue-on-error: false
        run: |
          terraform plan -no-color -out=tfplan
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

      # NEW: Convert binary plan to JSON format
      - name: Convert Plan to JSON
        id: plan_json
        working-directory: .
        run: terraform show -no-color -json tfplan > tfplan.json

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ github.run_id }} # Keep artifact name consistent for now
          path: tfplan.json # <-- Upload the JSON file

      - name: Create Plan Output for PR Comment
        id: plan_output
        if: github.event_name == 'pull_request'
        run: |
          echo "plan_output<<EOF" >> $GITHUB_OUTPUT
          echo '```terraform' >> $GITHUB_OUTPUT
          # Use the binary 'tfplan' for the readable 'terraform show' output for the comment
          terraform show -no-color tfplan >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        shell: bash

      - name: Post Plan to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `${{ steps.plan_output.outputs.plan_output }}`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  apply:
    name: Terraform Apply (${{ github.event.inputs.environment || 'main' }})
    needs: [plan, detect-topics]
    if: |
      needs.detect-topics.outputs.is_master == 'true' &&
      success() && 
      (
        (github.event_name == 'workflow_run' && github.ref == 'refs/heads/main') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true')
      )
    runs-on: ${{ github.event.inputs.runner_label || 'ubuntu-latest' }}
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.event.inputs.ref || github.ref }}

      - name: Determine Environment Name
        id: determine_env
        run: |
          ENV_NAME="${{ github.event.inputs.environment || 'main' }}"
          echo "Determined environment: $ENV_NAME"
          echo "environment_name=$ENV_NAME" >> $GITHUB_OUTPUT
          echo "secret_name=STATE_$(echo '$ENV_NAME' | tr '[:lower:]' '[:upper:]' | tr '-' '_')" >> $GITHUB_OUTPUT
        shell: bash

      - name: Check for Existing State Secret
        id: check_state_secret
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const secretName = '${{ steps.determine_env.outputs.secret_name }}';
            console.log(`Checking for secret: ${secretName}`);
            
            try {
              await github.rest.actions.getRepoSecret({
                owner: context.repo.owner,
                repo: context.repo.repo,
                secret_name: secretName
              });
              console.log(`Secret ${secretName} exists`);
              core.setOutput('exists', 'true');
            } catch (error) {
              if (error.status === 404) {
                console.log(`Secret ${secretName} does not exist`);
                core.setOutput('exists', 'false');
              } else {
                throw error;
              }
            }

      - name: Restore State File from Secret
        if: steps.check_state_secret.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const secretName = '${{ steps.determine_env.outputs.secret_name }}';
            
            console.log(`Restoring state from secret: ${secretName}`);
            
            // The secret value is available through the secrets context
            const encodedState = process.env[secretName];
            
            if (!encodedState) {
              throw new Error(`Secret ${secretName} is not available in environment`);
            }
            
            // The secret value is stored as base64, decode it
            const stateContent = Buffer.from(encodedState, 'base64').toString('utf8');
            
            // Write to terraform.tfstate
            fs.writeFileSync('terraform.tfstate', stateContent);
            console.log('State file restored successfully');
        env:
          ${{ steps.determine_env.outputs.secret_name }}: ${{ secrets[steps.determine_env.outputs.secret_name] }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: Terraform Init
        id: init
        working-directory: .
        continue-on-error: false
        run: |
          terraform init -backend=false
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

      - name: Terraform Apply
        id: apply
        working-directory: .
        continue-on-error: false
        run: |
          terraform apply -auto-approve
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

      - name: Save State File to Secret
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const sodium = require('tweetsodium');
            
            const secretName = '${{ steps.determine_env.outputs.secret_name }}';
            const stateFilePath = 'terraform.tfstate';
            
            // Check if state file exists
            if (!fs.existsSync(stateFilePath)) {
              console.log('No state file found to save');
              return;
            }
            
            // Read and encode the state file
            const stateContent = fs.readFileSync(stateFilePath, 'utf8');
            const encodedContent = Buffer.from(stateContent).toString('base64');
            
            // Get the repository's public key for encryption
            const { data: publicKey } = await github.rest.actions.getRepoPublicKey({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            // Encrypt the encoded content
            const messageBytes = Buffer.from(encodedContent);
            const keyBytes = Buffer.from(publicKey.key, 'base64');
            const encryptedBytes = sodium.seal(messageBytes, keyBytes);
            const encryptedValue = Buffer.from(encryptedBytes).toString('base64');
            
            // Create or update the secret
            try {
              await github.rest.actions.createOrUpdateRepoSecret({
                owner: context.repo.owner,
                repo: context.repo.repo,
                secret_name: secretName,
                encrypted_value: encryptedValue,
                key_id: publicKey.key_id,
              });
              console.log(`State file saved to secret: ${secretName}`);
            } catch (error) {
              console.error('Failed to save state file to secret:', error);
              throw error;
            }

      - name: Create Environment File
        run: |
          echo "${{ steps.determine_env.outputs.environment_name }}" > environment.txt
        shell: bash

      - name: Upload Environment Artifact
        uses: actions/upload-artifact@v4
        with:
          name: environment-${{ github.run_id }}
          path: environment.txt 